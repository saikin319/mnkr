<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>オンラインゲーム</title>
<style>
canvas { background: #ccc; display:block; margin: 0 auto; }
#chat { width: 500px; margin: 10px auto; }
#messages { border: 1px solid #999; height: 150px; overflow-y: scroll; padding: 5px; background: #fff; }
#input { width: 100%; }
</style>
</head>
<body>
<canvas id="game" width="500" height="500"></canvas>

<div id="chat">
    <div id="messages"></div>
    <input id="input" autocomplete="off" placeholder="チャット入力" />
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
const socket = io();
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const players = {};

let myName = prompt("名前を入力してください") || '名無し';
socket.emit('setName', myName);

const keysPressed = {};
let chatActive = false;

const input = document.getElementById('input');
const messages = document.getElementById('messages');

// Enterキーでチャット開始／送信
document.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        if (!chatActive) {
            input.focus();
            chatActive = true;
        } else if (input.value) {
            socket.emit('chatMessage', input.value);
            input.value = '';
            input.blur();
            chatActive = false;
        }
        e.preventDefault();
        return;
    }

    // 矢印キー押下で移動（チャット中でも可）
    if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)) {
        keysPressed[e.key] = true;
        e.preventDefault();
    }
});

document.addEventListener('keyup', (e) => {
    if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)) {
        keysPressed[e.key] = false;
        e.preventDefault();
    }
});

// チャット受信
socket.on('chatMessage', ({ name, msg }) => {
    const div = document.createElement('div');
    div.textContent = `${name}: ${msg}`;
    messages.appendChild(div);
    messages.scrollTop = messages.scrollHeight;
});

// プレイヤー同期
socket.on('currentPlayers', (data) => Object.assign(players, data));
socket.on('newPlayer', (data) => players[data.id] = { x: data.x, y: data.y, color: data.color, name: data.name });
socket.on('playerMoved', (data) => { if(players[data.id]) { players[data.id].x = data.x; players[data.id].y = data.y; } });
socket.on('playerDisconnected', (id) => delete players[id]);

// 移動処理
function handleMovement() {
    if (!players[socket.id]) return;

    let dir = null;
    if (keysPressed['ArrowLeft']) dir = 'left';
    else if (keysPressed['ArrowRight']) dir = 'right';
    else if (keysPressed['ArrowUp']) dir = 'up';
    else if (keysPressed['ArrowDown']) dir = 'down';

    if (dir) socket.emit('move', dir);
}

// 名前縁取り描画
function drawTextWithStroke(text, x, y, color = '#000', strokeColor = '#fff') {
    ctx.lineWidth = 3;
    ctx.strokeStyle = strokeColor;
    ctx.fillStyle = color;
    ctx.textAlign = 'center';
    ctx.font = '12px sans-serif';
    ctx.strokeText(text, x, y);
    ctx.fillText(text, x, y);
}

// 描画ループ
function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // 壁
    ctx.fillStyle = '#444';
    ctx.fillRect(0,0,500,10);      // 上
    ctx.fillRect(0,490,500,10);    // 下
    ctx.fillRect(0,0,10,500);      // 左
    ctx.fillRect(490,0,10,500);    // 右

    // プレイヤー描画
    for (const id in players) {
        const p = players[id];
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 20, 20);
    }

    // 名前描画
    for (const id in players) {
        const p = players[id];
        drawTextWithStroke(p.name, p.x + 10, p.y + 30);
    }

    handleMovement();
    requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
